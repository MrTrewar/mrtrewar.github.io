<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Particle Cloud</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: #eee; font-family: Arial, sans-serif; }
        #container { width: 100vw; height: 100vh; display: block; }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            color: #fff;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 250px;
        }
        #controls label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        #controls input[type="range"],
        #controls input[type="color"],
        #controls input[type="number"],
        #controls select,
        #controls button {
            margin-left: 10px;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #333;
            color: #eee;
        }
        #controls input[type="range"] { width: 100px; }
        #controls input[type="number"] { width: 60px; }
        #controls button { cursor: pointer; background-color: #4CAF50; border: none; }
        #controls button:hover { background-color: #45a049; }
        .control-group {
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            margin-bottom: 10px;
        }
        .control-group:last-child {
            border-bottom: none;
            padding-bottom: 0;
            margin-bottom: 0;
        }
        h4 { margin-top: 0; margin-bottom: 10px; color: #bbb; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="controls">
        <h4>Particle Cloud Controls</h4>

        <div class="control-group">
            <label for="particleCount">Count: <span id="particleCountValue">5000</span></label>
            <input type="range" id="particleCount" min="1000" max="20000" value="5000" step="100">
        </div>

        <div class="control-group">
            <label for="particleSize">Size: <span id="particleSizeValue">1.5</span></label>
            <input type="range" id="particleSize" min="0.1" max="10" value="1.5" step="0.1">
        </div>

        <div class="control-group">
            <label for="shape">Shape:</label>
            <select id="shape">
                <option value="sphere" selected>Sphere</option>
                <option value="cube">Cube</option>
                <option value="torus">Torus</option>
                <option value="helix">Helix</option>
            </select>
        </div>

        <div class="control-group">
            <h4>Coloring</h4>
            <label for="baseColor">Base Color:</label>
            <input type="color" id="baseColor" value="#00ffdd">
            <label for="colorVariation">Variation:</label>
            <input type="range" id="colorVariation" min="0" max="1" value="0.3" step="0.01">
            <button id="randomizeColors">Randomize Colors</button>
        </div>

        <div class="control-group">
            <h4>Animation</h4>
            <label for="animationSpeed">Speed:</label>
            <input type="range" id="animationSpeed" min="0.1" max="5" value="1" step="0.1">
            <button id="toggleRotation">Toggle Rotation</button>
        </div>

         <button id="resetParticles">Re-generate Particles</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script type="module">
        // Import OrbitControls if you want to use it.
        // For a single file like this, you'd usually include it as another <script> tag
        // or copy-paste its code. For simplicity, I'll skip OrbitControls,
        // but it's highly recommended for better interaction.
        // import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js';

        let scene, camera, renderer;
        let particles, geometry, material;
        let particleCount = 5000;
        let currentShape = 'sphere';
        let baseColor = new THREE.Color(0x00ffdd);
        let colorVariation = 0.3;
        let particleSize = 1.5;
        let animationSpeed = 1;
        let isRotating = true;

        const particleCountSlider = document.getElementById('particleCount');
        const particleCountValue = document.getElementById('particleCountValue');
        const particleSizeSlider = document.getElementById('particleSize');
        const particleSizeValue = document.getElementById('particleSizeValue');
        const shapeSelector = document.getElementById('shape');
        const baseColorPicker = document.getElementById('baseColor');
        const colorVariationSlider = document.getElementById('colorVariation');
        const randomizeColorsButton = document.getElementById('randomizeColors');
        const animationSpeedSlider = document.getElementById('animationSpeed');
        const toggleRotationButton = document.getElementById('toggleRotation');
        const resetParticlesButton = document.getElementById('resetParticles');

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 150;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            // Particle Texture
            const particleTexture = createParticleTexture();

            material = new THREE.PointsMaterial({
                size: particleSize,
                map: particleTexture,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false // Often better for additive blending
            });

            createParticles();
            
            window.addEventListener('resize', onWindowResize, false);
            setupControls();
            animate();
        }

        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width / 2
            );
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.4, 'rgba(255,255,255,0.3)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            return new THREE.CanvasTexture(canvas);
        }

        function createParticles() {
            if (particles) {
                scene.remove(particles);
                geometry.dispose();
            }

            geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const targetPositions = new Float32Array(particleCount * 3); // For animation

            // Initial positions (will be animated to shape)
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 200;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 200;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 200;
                setParticleColor(colors, i);
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('targetPosition', new THREE.BufferAttribute(targetPositions, 3)); // Store target

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            updateShape(currentShape, false); // false: don't animate initial setup
        }

        function setParticleColor(colorArray, index) {
            const variedColor = baseColor.clone();
            variedColor.r += (Math.random() - 0.5) * colorVariation * 2;
            variedColor.g += (Math.random() - 0.5) * colorVariation * 2;
            variedColor.b += (Math.random() - 0.5) * colorVariation * 2;
            variedColor.r = Math.max(0, Math.min(1, variedColor.r));
            variedColor.g = Math.max(0, Math.min(1, variedColor.g));
            variedColor.b = Math.max(0, Math.min(1, variedColor.b));
            colorArray[index * 3] = variedColor.r;
            colorArray[index * 3 + 1] = variedColor.g;
            colorArray[index * 3 + 2] = variedColor.b;
        }

        function updateShape(shape, useAnimation = true) {
            currentShape = shape;
            const positions = geometry.attributes.position.array;
            const targetPositions = geometry.attributes.targetPosition.array; // Get reference to our target buffer

            for (let i = 0; i < particleCount; i++) {
                let x, y, z;
                const idx = i * 3;

                switch (shape) {
                    case 'sphere':
                        const phi = Math.acos(-1 + (2 * i) / particleCount);
                        const theta = Math.sqrt(particleCount * Math.PI) * phi;
                        const radius = 80;
                        x = radius * Math.sin(phi) * Math.cos(theta);
                        y = radius * Math.sin(phi) * Math.sin(theta);
                        z = radius * Math.cos(phi);
                        break;
                    case 'cube':
                        const sideLength = 120;
                        x = (Math.random() - 0.5) * sideLength;
                        y = (Math.random() - 0.5) * sideLength;
                        z = (Math.random() - 0.5) * sideLength;
                        break;
                    case 'torus':
                        const R = 60; // Major radius
                        const r = 30; // Minor radius
                        const u = Math.random() * 2 * Math.PI;
                        const v = Math.random() * 2 * Math.PI;
                        x = (R + r * Math.cos(v)) * Math.cos(u);
                        y = (R + r * Math.cos(v)) * Math.sin(u);
                        z = r * Math.sin(v);
                        break;
                    case 'helix':
                        const helixRadius = 50;
                        const helixHeight = 150;
                        const turns = 5;
                        const t = (i / particleCount) * turns * 2 * Math.PI;
                        x = helixRadius * Math.cos(t);
                        y = (i / particleCount - 0.5) * helixHeight;
                        z = helixRadius * Math.sin(t);
                        break;
                }
                targetPositions[idx] = x;
                targetPositions[idx + 1] = y;
                targetPositions[idx + 2] = z;
            }
            geometry.attributes.targetPosition.needsUpdate = true; // Important!

            if (useAnimation) {
                // Anime.js for positions
                // We need to create a dummy object for anime.js to tween
                // and then use its values in the update callback.
                // For each particle, we animate from current to target.
                
                // A more efficient way for many particles is to have one anime timeline
                // that drives the progress of all interpolations.
                const progress = { value: 0 };
                anime.remove(positions); // Remove any existing animations on positions array
                anime({
                    targets: progress,
                    value: 1,
                    duration: 1500,
                    easing: 'easeInOutExpo',
                    update: function() {
                        for (let i = 0; i < particleCount; i++) {
                            const idx = i * 3;
                            // Interpolate from current position (stored in 'position' attribute)
                            // to 'targetPosition' attribute
                            // At the start of animation, currentPos is the actual position.
                            // We need a snapshot of initial positions for smooth lerp if particles are already moving.
                            // For simplicity here, we assume 'positions' array IS the current visual state.
                            // If particles had independent physics, this would need adjustment.
                            
                            // Let's store initial positions at the moment of transition
                            // This is slightly complex as geometry.attributes.position is dynamic
                            // A simpler approach, if performance allows, is to create temp storage
                            // For this demo, we'll lerp directly using the targetPosition buffer and current position.
                            // To make it smoother if called mid-animation, you'd need to capture
                            // the 'true' current positions before starting a new tween.
                            
                            // Correct way:
                            // If this is the first animation, originalPosition = currentPosition.
                            // If called again, originalPosition is what it was before the *current* animation call.
                            // For now, we'll directly animate from current to target.

                            positions[idx] = positions[idx] + (targetPositions[idx] - positions[idx]) * progress.value;
                            positions[idx+1] = positions[idx+1] + (targetPositions[idx+1] - positions[idx+1]) * progress.value;
                            positions[idx+2] = positions[idx+2] + (targetPositions[idx+2] - positions[idx+2]) * progress.value;

                            // If we're doing a simpler tween:
                            // This is not ideal if updateShape is called rapidly,
                            // as the 'from' value keeps changing.
                            // A better way is to store original positions *before* any animation starts,
                            // and always tween from original to target.
                            // However, for a single transition, this works:
                            if (progress.value < 0.01) { // Capture start positions if this is a new animation run
                                // This logic is tricky for repeated calls.
                                // Anime.js typically tweens properties on an object.
                                // For buffer attributes, we often manage the lerp manually in update.
                            }
                        }
                        geometry.attributes.position.needsUpdate = true;
                    },
                    complete: function() {
                        // Snap to final target positions to avoid floating point inaccuracies
                        for (let i = 0; i < particleCount; i++) {
                            const idx = i * 3;
                            positions[idx] = targetPositions[idx];
                            positions[idx + 1] = targetPositions[idx + 1];
                            positions[idx + 2] = targetPositions[idx + 2];
                        }
                        geometry.attributes.position.needsUpdate = true;
                    }
                });

            } else { // No animation, just set directly
                for (let i = 0; i < particleCount; i++) {
                    const idx = i * 3;
                    positions[idx] = targetPositions[idx];
                    positions[idx + 1] = targetPositions[idx + 1];
                    positions[idx + 2] = targetPositions[idx + 2];
                }
                geometry.attributes.position.needsUpdate = true;
            }
        }

        function updateColors(useAnimation = true) {
            const colors = geometry.attributes.color.array;
            const tempColorObjects = []; // For anime.js to tween

            for (let i = 0; i < particleCount; i++) {
                const oldColor = { r: colors[i*3], g: colors[i*3+1], b: colors[i*3+2] };
                tempColorObjects.push(oldColor);
                
                const variedColor = baseColor.clone();
                variedColor.r += (Math.random() - 0.5) * colorVariation * 2;
                variedColor.g += (Math.random() - 0.5) * colorVariation * 2;
                variedColor.b += (Math.random() - 0.5) * colorVariation * 2;
                variedColor.r = Math.max(0, Math.min(1, variedColor.r));
                variedColor.g = Math.max(0, Math.min(1, variedColor.g));
                variedColor.b = Math.max(0, Math.min(1, variedColor.b));

                if (useAnimation) {
                    anime({
                        targets: tempColorObjects[i],
                        r: variedColor.r,
                        g: variedColor.g,
                        b: variedColor.b,
                        duration: 1000,
                        easing: 'linear',
                        update: () => {
                            colors[i*3] = tempColorObjects[i].r;
                            colors[i*3+1] = tempColorObjects[i].g;
                            colors[i*3+2] = tempColorObjects[i].b;
                            geometry.attributes.color.needsUpdate = true;
                        }
                    });
                } else {
                    colors[i*3] = variedColor.r;
                    colors[i*3+1] = variedColor.g;
                    colors[i*3+2] = variedColor.b;
                }
            }
            if (!useAnimation) {
                geometry.attributes.color.needsUpdate = true;
            }
        }


        function setupControls() {
            particleCountSlider.addEventListener('input', (e) => {
                particleCountValue.textContent = e.target.value;
            });
            particleCountSlider.addEventListener('change', (e) => { // Use change for less frequent updates
                particleCount = parseInt(e.target.value);
                createParticles(); // This will re-initialize with the new count and current shape
            });

            particleSizeSlider.addEventListener('input', (e) => {
                particleSize = parseFloat(e.target.value);
                particleSizeValue.textContent = particleSize.toFixed(1);
                if (material) material.size = particleSize;
            });

            shapeSelector.addEventListener('change', (e) => {
                updateShape(e.target.value);
            });

            baseColorPicker.addEventListener('input', (e) => {
                baseColor.set(e.target.value);
                updateColors(true); // Animate color change
            });

            colorVariationSlider.addEventListener('input', (e) => {
                colorVariation = parseFloat(e.target.value);
                updateColors(true); // Animate color change
            });
            
            randomizeColorsButton.addEventListener('click', () => {
                // Generate a random new base color
                baseColor.setRGB(Math.random(), Math.random(), Math.random());
                baseColorPicker.value = "#" + baseColor.getHexString(); // Update picker
                updateColors(true);
            });

            animationSpeedSlider.addEventListener('input', (e) => {
                animationSpeed = parseFloat(e.target.value);
            });

            toggleRotationButton.addEventListener('click', () => {
                isRotating = !isRotating;
                toggleRotationButton.textContent = isRotating ? "Pause Rotation" : "Resume Rotation";
            });

            resetParticlesButton.addEventListener('click', () => {
                // This will re-initialize everything with current settings
                createParticles();
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (particles && isRotating) {
                particles.rotation.x += 0.0005 * animationSpeed;
                particles.rotation.y += 0.001 * animationSpeed;
            }
            
            // The Anime.js update functions handle geometry.attributes.X.needsUpdate = true
            // So we don't explicitly need it here unless other things modify geometry.

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>